(function(){"use strict";angular.module("angularClazzApp",["ngAnimate","ngRoute","ngTouch","ngSanitize","ui.ace"]).config(["$routeProvider",function(a){return a.when("/",{templateUrl:"views/main.html",controller:"MainCtrl"}).otherwise({redirectTo:"/"})}])}).call(this),function(){"use strict";angular.module("angularClazzApp").controller("MainCtrl",["$scope",function(a){return a.prelude=[{injectable:"class OO.Injectable\n  @inject: (args...) ->\n    (args.push(injectee) if args.indexOf(injectee) is - 1) for injectee in [(@$inject ? [])...]\n    @$inject = args\n    @",explanation:"The inject class - method provides for angular - DI.\nInvoke it at the top of your child - class, passing in the dependencies as strings.\nEach Injectee will become available as a member var, accessible via <code> @Injectee</code>, eg. <code>@$scope</code> !\nPlease remark that some extended base classes, like the Widget - Class for example, do host certain Injectees by default."},{injectable:'class OO.Ctrl extends OO.Injectable\n  @register: (app, name) ->\n    name ?= @name or @toString().match(/functions*(.*?)(/)?[1]\n    if typeof app is "string" then angular.module(app).controller name, @\n    else app.controller name, @\n    @\nclass OO.Service extends OO.Injectable\n  @register: (app, name) ->\n    name ?= @name or @toString().match(/functions*(.*?)(/)?[1]\n    if typeof app is "string" then angular.module(app).service name, @\n    else app.service name, @\n    @',explanation:"The basic Controller vs. Service Registration class - methods. They enable auto - registration of classes as Angular - Instances.\nIf used by your child - class, you can directly access such an instance in a directive via its string - name."},{injectable:'class OO.Ctrl #continued\n  @mixin: (mixins...) ->\n    class Mixed extends @\n    for mixin in mixins\n        for name, method of mixin.prototype\n            (() ->\n                m = method\n                _m = Mixed::[name]\n                n = name\n                if name is "initialize" and Mixed::initialize?\n                    Mixed::initialize = () ->\n                        m.call @\n                        _m.call @\n                else if name isnt "constructor" and not Mixed::[name]? then Mixed::[name] = m\n            )()\n        (Mixed[name] = method) for own name, method of mixin when angular.isFunction method\n        Mixed.inject.apply Mixed, mixin.$inject\n    Mixed',explanation:"Controllers allow for smart multiple inheritance. If a method already exists down the prototype chain,\nthe current method is merged and appended after the 'older' method in a new prototypal function."},{injectable:'class Ctrl #...again continued\n  @implements: (interfaces...) ->\n    class Interfaced extends @\n    for Interface in interfaces\n        do (Interface) ->\n            Interfaced::[Interface] = () -> throw {\n                msg: "Looks like the interface _{Interface}_ hasn\'t been implemented! This will lead to unpredictable behaviour!"\n            }\n    Interfaced',explanation:"The implements class - method allows for Java - like notation. Applying it on a base class kind of forces, but really advises, the extending logic to (re - ) implement the function."},{injectable:'class Ctrl #...still continued\n  constructor: (args...) ->\n    (@[key] = args[index]) for key, index in @constructor.$inject\n    for key, fn of @constructor.prototype when typeof fn is "function" and ["constructor", "initialize"].indexOf(key) is -1 and key[0] isnt "_"\n      do (key, fn) =>\n        if key.match "::"\n          t = key.split "::"\n          if t[2]? and t[2].indexOf(">") isnt -1 then t = t.splice(0, 2).concat t[0].split ">"\n          for el, i in (t[0] and $(t[0], @element?.context ? document.body) or [@$element?.context])\n            do (el, i) =>\n                listenerO = [t[1]]\n                listenerO.push(t[2]) if t[2]?\n                listenerO.push (args...) =>\n                  if t[2]?\n                      ev = args[0]\n                      if t[3]? then @$scope.n = $(ev.currentTarget).closest(t[3]).index()\n                      else (@$scope.n = j) for el, j in $(ev.currentTarget).parent().children().get() when el is ev.currentTarget\n                  fn.apply @, args\n                  if not @$scope.$$phase then @$scope.$digest()\n\n                angular.element(el).on.apply angular.element(el), listenerO\n        else\n            @$scope[key] = (args...) =>\n                fn.apply @, args\n                @\n    @initialize?()',explanation:"The Controller - Base - Class's constructor initializes and hooks into angular to realize the actual Dependency Injection.\nFurthermore it provides for can.js like jQuery - selector controller - based eventing and also provides an scoped index - var <code> @$scope.n</code> .\n(Due to this mechanism full - blown jQuery is a hard dependency of the plugin. The author dislikes the fact, but thinks it's worth it.)\nPrototype methods are available not only directly, but also are attached to <code> @$scope</code> , should they not be prefixed with an _underscrode.\nThis way, you can, should you really want to, always use angular's intrinsic system of html - attribute eventing.\nFinally it invokes, should it exist, your class's pseudo constructor: initialize."},{injectable:'class OO.DataService extends OO.Service\n    @inject "$resource", "$interval", "$q"\n    _db: (api, { @name, @persistant, @oneshot, @interval} ) ->\n      @persistant ?= false\n      @oneshot = not @interval?\n      @q ?= @$q.defer()\n      @db =\n          busy: false\n          ready: false\n          handle: if api? then @$resource(api) else null\n          store: @persistant and _DB.create(@name) or []\n\n      @_api()\n      @oneshot or @$interval @_api.bind(@), @interval\n      @q.promise\n    _api: () ->\n      if @db.busy is true then return\n      @db.busy = true\n      @db.handle.get().$promise\n          .then (data) =>\n              console.info "success {@name}"\n              @_store(data[@name] ? data)\n              @db.busy = false\n              if not @persistant\n                  if @oneshot is true\n                      @q.resolve()\n                      @q = null\n                  else @q.notify(true)\n              @db.ready = true\n          .catch (err) =>\n              console.warn "err {@name}"\n              if @oneshot is true\n                  @q.reject()\n                  @q = null\n              else\n                  @q.notify(false)\n    _store: (data) ->\n      if @persistant\n          for o in data\n              do (o) =>\n                  @db.store.query((doc, emit) -> if doc.id is o.id then emit doc)\n                      .then (doc) =>\n                          console.info \'#Data for id _{o.id}_ will be updated now\'\n                          if doc.error isnt "not_found" and doc.total_rows is 1\n                              o._id = doc.rows[0].key._id\n                              o._rev = doc.rows[0].key._rev\n                      .catch (err) =>\n                          console.warn "db error: couldn\'t query for {o.id}"\n                          throw err.toString()\n                      .finally (args...) =>\n                          @db.store.put(o, o.id, o._rev)\n                              .then (response) =>\n                                  if @oneshot is true\n                                      @q.resolve()\n                                      @q = null\n                                  else @q.notify(true)\n                              .catch (err) =>\n                                  console.warn "db error: couldn\'t put {o.toString()}"\n                                  if @oneshot is true\n                                      @q.reject()\n                                      @q = null\n                                  else\n                                      @q.notify(false)\n      else\n          (o.deleted = true) for o in @db.store\n          for o in data\n              do (o) =>\n                  if (i = @db.store.indexOf(@db.store.filter (el) -> el.id is o.id)) isnt - 1\n                      (@db.store[i][k] = o[k]) for own k, v of o\n                      @db.store[i].deleted = false\n                  else\n                      @db.store.push o\n                      @db.store[@db.store.length - 1].deleted = false',explanation:"The Service - Base - Class is to be used by extension asusual, invoking solely the _db method with it's params due.\nOnce initiated, everything should be automated. Long - Polling, oneshot api calls, persistance via (angular - ) pouchdb or fast in - memory ...\nYou will be able to react to new data via it's (the _db methods) returned promise."},{injectable:'class OO.Widget extends OO.Ctrl\n  @inject "$element"',explanation:"Lastly, I provide for an extra Widget - Base - Class. It solely provides for the $element injectable. Please do use\nthis base class for your UI - Controllers and the Ctrl - Base - Class for any Rounting - Controllers, which are because of it's config - block early - stages initialization\nnot able to receive the <code>$element</code> injectable.\nThe $element injectable is needed for a certain mechanism in the eventing functionality. Basically it stops watching events further up the line as the container tag."}],a.action=[{injectable:"Clazz = angular.injector(['angular-clazz'])?.get? 'Clazz'",explanation:"Now let's see the plugin in action.\nI for one tend to organize my different classes in separate files - separation of concern-like.\n<ul>\n    <li>There's a lib coffee that might backfeed my personal library at some point. It serves for my base functionality/classes.</li>\n    <li>There's a services coffee.</li>\n    <li>There's a main coffee for the routing controllers</li>\n    <li>And there's a ui coffee for the regular controllers</li>\n</ul>\nNow there rises a question as how to start. Where will I inject the plugin and what about a module dependency?\nEasy come, easy go. You could inject the plugin as a module dependency, but then, where would you inject it?\nI just boasted that the module is capable of registering the class as a services/controller all by itself by a class-method <code>@register</code> ...\nGladly, there is the <code>angular.injector([String, String2, ...])</code> method. We'll use it like so:"},{explanation:"So let's start by adding an evil<sup>tm</sup> Main-Controller. Basically I'm talking Routing-Controllers here, so not a directive's controller, but a Ctrl you'd use for a <code>$routeProvider.when(...)</code>-block.\nSince it is not a Widget and shall-not-manipulate-the-DOM<sup>tm</sup>, but rather ... ok, what exactly are those kind of controllers for anyway?!?\nMaybe we'll handle Credentials/Server-side-login here. So let's assume we're basically checking authentication during initialization ... maybe it looks like:",injectable:'class Main extends Clazz.Ctrl\n\n    @inject "MyConfigValue", "$location", "$http"\n    @register "myAppMod", "Main"\n\n    initialize: () ->\n        @$http.get(\'/path/to/auth-check\').success (response) =>\n            if response.yourJsonFormat is "yourBool"\n                @MyConfigValue.importantSetting = true\n                @$location.url "my/new/path/to/my/secure/page"'},{explanation:"OK, but this might be not the best of use cases. Let's move on.\nSo, in fact, I think it best to organize all pattern-triples into widgets - kinda resembling the upcoming web-components.\n<em>Don't forget, for data communication we gotta use Services!</em>\nSo, let's build a Widget/Directive!\nWe'll inject a custom Service I'll show you later how to create/use, we'll use behaviours and we'll properly use functional inheritance.\n<br><br>\nTo use behaviours, the annotation style is as following: <code>\"CssSelection::jQueryEvent\": foo</code><br>\nTo use the same behaviour in a dynamically created element we can use delegates like:<br><code>[optional, defaults to $element]parentElCssSelection::jQueryEvent::triggerElCssSelection[optional: >parentSiblingElCssSelection]</code><br>\nSo, you could write: <code>\"::click::i.fa.fa-home>li.navitem\"</code> to cover the case of a dynamically created Nav which is only triggered by a part of the `sub-component/partial` that might be the nav-el.<br>\n<em>Why?</em> Usually you'll want to identify the sibling clicked by a counter, which will be auto-available (and auto-updated on event) as <code>@$scope.n</code>. To give me a chance to identify which element I'm to calculate\nthe sibling-count of, we might need to add the <code>&gt;parentSiblingElCssSelection</code>-symbol. If you trigger via a valid sibling itself, there's no such need.",injectable:'class MyWidget extends Clazz.Widget\n.mixin MyClazzyLib.StandardBehaviours, MyClazzyLib.HelperFoos\n\n    @inject "MyConfigValuesPseudoGlobal", "MyDataService", "$interval", "$timeout"\n    @register "myAppMod", "MyWidget"\n\n    initialize: () =>\n        @_api = {\n            module: @MyConfigValuesPseudoGlobal.modules.specificModuleType.path\n            sub: @MyConfigValuesPseudoGlobal.modules.specificModuleType.sub.specificWidgetInterest.path\n        }\n\n        initInterval = @$interval () =>\n            promise = MyDataService.get @_api\n            promise.then (response) =>\n                @$interval.cancel initInterval\n                MyDataService.digestAndTriggerListeners?()\n            promise.catch () => console.warn "Having trouble initializing the Widget ... retrying to fetch base data"\n\n        super\n\n    ".logout.button::click": () =>\n        @_doSomethingSpecific() #underscore prefixed class methods are kinda ng-private, they don\'t make a copy of themselves in @$scope\n        @_behaviours "logout" #say we inherited that foo from MyClayyzLib.StandardBehaviours - and it seems to be a factory too :)\n\n    "::sortstop::.sortable": () =>\n        return false #TODO: implement behaviour on jQueryUI sorting :)\n\n    mutation: (service) =>\n        #You might want to create an extended BaseDataService that implements Listener mechanisms and triggers this method on change\n        switch service\n            when "MyDataService"\n                @$scope.data.widgetSpecific = @MyDataService.db.store.widgetSpecificData\n                #trigger digest cycle or something ...\n            when "SomeOtherDataService"\n                @$scope.data.widgetSpecific2 #TODO hook it up'}]}])}.call(this);